# 自动化测试核心技术详解

## 一、参数化测试 (Parametrize)

### 原理
**一次编写测试逻辑，自动用多组数据重复执行**

### 问题场景
假设要测试图像缩放功能，需要测试多种尺寸：
- 100x100 放大2倍 = 200x200
- 640x480 放大3倍 = 1920x1440
- 1024x768 放大1.5倍 = 1536x1152
- 800x600 放大4倍 = 3200x2400

### 传统方式 (重复代码)
```python
def test_scale_100x100(self):
    result_w = int(100 * 2.0)
    result_h = int(100 * 2.0)
    assert result_w == 200
    assert result_h == 200

def test_scale_640x480(self):
    result_w = int(640 * 3.0)
    result_h = int(480 * 3.0)
    assert result_w == 1920
    assert result_h == 1440

def test_scale_1024x768(self):
    result_w = int(1024 * 1.5)
    result_h = int(768 * 1.5)
    assert result_w == 1536
    assert result_h == 1152

def test_scale_800x600(self):
    result_w = int(800 * 4.0)
    result_h = int(600 * 4.0)
    assert result_w == 3200
    assert result_h == 2400
```
**问题**: 重复代码多，维护困难

### 参数化方式 (自动化)
```python
@pytest.mark.parametrize("width,height,scale,expected_w,expected_h", [
    (100, 100, 2.0, 200, 200),        # 第1组数据
    (640, 480, 3.0, 1920, 1440),      # 第2组数据
    (1024, 768, 1.5, 1536, 1152),     # 第3组数据
    (800, 600, 4.0, 3200, 2400),      # 第4组数据
])
def test_multiple_scale_scenarios(self, width, height, scale, expected_w, expected_h):
    """一个测试函数，自动运行4次"""
    result_w = int(width * scale)
    result_h = int(height * scale)
    
    assert result_w == expected_w
    assert result_h == expected_h
```

### 工作原理
```
1. pytest 读取 @pytest.mark.parametrize 装饰器
2. 解析参数列表: ["width", "height", "scale", "expected_w", "expected_h"]
3. 解析数据列表: [(100, 100, 2.0, 200, 200), ...]
4. 自动生成4个测试用例:
   - test_multiple_scale_scenarios[100-100-2.0-200-200]
   - test_multiple_scale_scenarios[640-480-3.0-1920-1440]
   - test_multiple_scale_scenarios[1024-768-1.5-1536-1152]
   - test_multiple_scale_scenarios[800-600-4.0-3200-2400]
5. 依次执行每个测试用例
6. 报告每个用例的通过/失败状态
```

### 实际运用 - 降噪等级测试
```python
@pytest.mark.parametrize("noise_level", [-1, 0, 1, 2, 3])
def test_valid_noise_levels(self, noise_level):
    """测试5个有效的降噪等级"""
    valid_levels = [-1, 0, 1, 2, 3]
    assert noise_level in valid_levels
```

**执行结果**:
```
test_valid_noise_levels[-1] PASSED
test_valid_noise_levels[0] PASSED
test_valid_noise_levels[1] PASSED
test_valid_noise_levels[2] PASSED
test_valid_noise_levels[3] PASSED
```

### 优势
✅ **减少重复代码**: 1个函数替代N个函数
✅ **易于扩展**: 添加新测试数据只需加一行
✅ **清晰的测试报告**: 每组数据独立显示结果
✅ **提高覆盖率**: 轻松测试更多场景

---

## 二、Fixture (测试夹具)

### 原理
**自动准备测试环境，测试完成后自动清理**

### 问题场景
每个测试都需要:
1. 创建Qt应用实例
2. 准备测试图片路径
3. 配置测试环境
4. 测试完成后清理资源

### 传统方式 (手动准备和清理)
```python
def test_load_image(self):
    # 每个测试都要手动准备
    app = QApplication.instance()
    if app is None:
        app = QApplication(sys.argv)
    
    test_dir = os.path.dirname(__file__)
    image_path = os.path.join(test_dir, "test_data", "sample.jpg")
    
    # 测试逻辑
    assert os.path.exists(image_path)
    
    # 手动清理
    # ...

def test_process_image(self):
    # 又要重复准备一次
    app = QApplication.instance()
    if app is None:
        app = QApplication(sys.argv)
    
    test_dir = os.path.dirname(__file__)
    image_path = os.path.join(test_dir, "test_data", "sample.jpg")
    
    # 测试逻辑
    # ...
```
**问题**: 每个测试都重复准备代码

### Fixture方式 (自动化)
```python
# 定义Fixture (在conftest.py中)
@pytest.fixture(scope="session")
def qapp():
    """创建Qt应用，整个测试会话共享"""
    app = QApplication.instance()
    if app is None:
        app = QApplication(sys.argv)
    yield app  # 提供给测试使用
    # yield后面的代码在测试完成后自动执行 (清理)

@pytest.fixture
def sample_image_path():
    """提供测试图片路径"""
    test_dir = os.path.dirname(__file__)
    return os.path.join(test_dir, "test_data", "sample.jpg")

# 使用Fixture (在测试文件中)
def test_load_image(qapp, sample_image_path):
    """pytest自动注入qapp和sample_image_path"""
    # 直接使用，无需手动准备
    assert os.path.exists(sample_image_path)

def test_process_image(qapp, sample_image_path):
    """自动获取相同的资源"""
    # 直接使用
    # ...
```

### 工作原理
```
测试执行流程:
1. pytest发现测试函数 test_load_image(qapp, sample_image_path)
2. 分析参数: qapp, sample_image_path
3. 查找对应的@pytest.fixture
4. 执行fixture函数:
   - 执行qapp()，创建Qt应用
   - 执行sample_image_path()，获取路径
5. 将返回值注入测试函数
6. 执行测试函数
7. 测试完成后，执行yield后面的清理代码
```

### Fixture的Scope (作用域)

#### 1. function (默认) - 每个测试函数独立
```python
@pytest.fixture  # scope="function"
def temp_file():
    """每个测试创建新文件"""
    file = open("temp.txt", "w")
    yield file
    file.close()  # 每个测试后删除
    os.remove("temp.txt")

def test_1(temp_file):  # 创建temp.txt
    temp_file.write("test1")
    # 测试完成后自动删除

def test_2(temp_file):  # 重新创建temp.txt
    temp_file.write("test2")
    # 测试完成后自动删除
```

#### 2. session - 整个测试会话共享
```python
@pytest.fixture(scope="session")
def qapp():
    """所有测试共享一个Qt应用"""
    app = QApplication(sys.argv)
    yield app
    # 所有测试完成后才清理

def test_1(qapp):  # 使用共享的app
    pass

def test_2(qapp):  # 使用同一个app
    pass
```

### 实际运用 - Mock配置
```python
@pytest.fixture
def mock_config():
    """自动准备测试配置，测试后自动恢复"""
    from conf import config
    
    # 1. 保存原始值
    original_can_waifu2x = config.CanWaifu2x
    original_gpu = config.Gpu
    
    # 2. 设置测试值
    config.CanWaifu2x = False  # 禁用GPU
    config.Gpu = -1
    
    # 3. 提供给测试使用
    yield config
    
    # 4. 测试完成后自动恢复
    config.CanWaifu2x = original_can_waifu2x
    config.Gpu = original_gpu

def test_without_gpu(mock_config):
    """自动使用测试配置"""
    assert mock_config.CanWaifu2x == False
    # 测试完成后自动恢复原始配置
```

### 优势
✅ **自动准备**: 无需手动初始化
✅ **自动清理**: 防止资源泄漏
✅ **代码复用**: 多个测试共享同一准备逻辑
✅ **依赖注入**: pytest自动管理依赖关系

---

## 三、Mock (模拟对象)

### 原理
**用假对象替换真实对象，避免依赖外部资源**

### 问题场景
测试图像处理功能时:
- ❌ 需要真实的GPU硬件
- ❌ 需要网络连接
- ❌ 需要读写文件系统
- ❌ 测试慢、不稳定、依赖环境

### 为什么需要Mock？

#### 场景1: GPU依赖
```python
def process_image(image_data):
    """真实函数需要GPU"""
    if config.CanWaifu2x:
        # 调用GPU进行处理 (需要真实硬件)
        result = waifu2x_process(image_data)
        return result
    return None
```

**问题**:
- 测试机器可能没有GPU
- GPU处理很慢 (几秒到几分钟)
- 测试失败可能是GPU驱动问题，不是代码问题

#### 场景2: 网络依赖
```python
def download_model():
    """从网络下载模型"""
    response = requests.get("https://example.com/model.bin")
    return response.content
```

**问题**:
- 网络不稳定
- 下载慢
- 服务器可能宕机

### Mock方式 (自动化)

#### 1. Mock配置对象
```python
@pytest.fixture
def mock_config():
    """模拟配置，禁用GPU"""
    from conf import config
    original = config.CanWaifu2x
    
    config.CanWaifu2x = False  # 用False替换真实值
    yield config
    
    config.CanWaifu2x = original

def test_without_gpu(mock_config):
    """测试时不需要真实GPU"""
    assert mock_config.CanWaifu2x == False
    # 代码逻辑正确即可，不依赖硬件
```

#### 2. Mock函数调用
```python
from unittest.mock import Mock, patch

def test_task_submission(self):
    """模拟任务提交"""
    # 创建Mock对象
    mock_add_task = Mock(return_value=1001)
    
    # 调用Mock对象
    task_id = mock_add_task(
        b"image_data",
        {'scale': 2.0},
        callback_function
    )
    
    # 验证
    assert task_id == 1001  # Mock返回的假值
    mock_add_task.assert_called_once()  # 验证被调用了1次
```

#### 3. Mock回调函数
```python
def test_callback_invocation(self):
    """测试回调是否被调用"""
    # 创建Mock回调
    callback_called = []
    
    def mock_callback(data, task_id, param, tick):
        callback_called.append({
            'data': data,
            'task_id': task_id,
            'tick': tick
        })
    
    # 创建任务
    task = QtDownloadTask()
    task.downloadCompleteBack = mock_callback
    task.saveData = b"processed_data"
    
    # 模拟任务完成
    task.downloadCompleteBack(task.saveData, 1001, None, 2.5)
    
    # 验证回调被调用
    assert len(callback_called) == 1
    assert callback_called[0]['task_id'] == 1001
```

### Mock的工作原理
```
1. 创建假对象 (Mock)
2. 定义假对象的行为 (return_value)
3. 用假对象替换真实对象
4. 执行测试
5. 验证假对象是否被正确调用
6. 测试完成后恢复真实对象
```

### 实际运用 - 你的项目

#### mock_config Fixture
```python
@pytest.fixture
def mock_config():
    """模拟配置对象"""
    from conf import config
    original_can_waifu2x = config.CanWaifu2x
    
    # Mock: 禁用GPU，避免测试依赖硬件
    config.CanWaifu2x = False
    
    yield config
    
    # 恢复: 测试后还原
    config.CanWaifu2x = original_can_waifu2x
```

**使用**:
```python
def test_task_id_increment(self, mock_config):
    """使用mock_config，测试时不需要GPU"""
    from src.qt.util.qttask import QtTask
    
    task_manager = QtTask()
    # 测试任务ID逻辑，不涉及真实GPU处理
    assert task_manager.taskId >= 0
```

### Mock的三种常用方式

#### 1. Mock对象
```python
from unittest.mock import Mock

mock_obj = Mock()
mock_obj.method.return_value = "fake_result"
result = mock_obj.method()
assert result == "fake_result"
```

#### 2. MagicMock (自动Mock所有属性)
```python
from unittest.mock import MagicMock

mock_obj = MagicMock()
mock_obj.any_method()  # 自动返回Mock对象
mock_obj.any_attribute  # 自动返回Mock对象
```

#### 3. patch装饰器 (临时替换)
```python
from unittest.mock import patch

@patch('src.qt.util.qttask.QtTask.AddConvertTask')
def test_task_submission(self, mock_add_task):
    """临时替换AddConvertTask方法"""
    mock_add_task.return_value = 1001
    
    # 调用被替换的方法
    task_id = mock_add_task(b"data", {}, callback)
    
    assert task_id == 1001
    # 测试完成后自动恢复原方法
```

### 优势
✅ **隔离依赖**: 不需要GPU、网络、数据库
✅ **测试快速**: 秒级完成，不等待外部资源
✅ **测试稳定**: 不受外部环境影响
✅ **可控性强**: 可以模拟任何场景(成功、失败、异常)

---

## 四、信号测试 (Qt Signal Testing)

### 原理
**验证Qt信号槽机制是否正确工作**

### Qt信号槽机制回顾
```python
# 定义信号
class QtTaskQObject(QObject):
    convertBack = Signal(int)  # 信号: 发送int类型数据

# 连接信号到槽函数
def slot_function(task_id):
    print(f"收到任务ID: {task_id}")

task_obj = QtTaskQObject()
task_obj.convertBack.connect(slot_function)

# 发射信号
task_obj.convertBack.emit(1001)  # 触发slot_function(1001)
```

### 问题场景
在你的项目中:
```
任务完成 → 发射信号 → 触发回调 → 更新UI
```

需要测试:
1. 信号是否正确定义？
2. 信号能否正确连接？
3. 信号发射后槽函数是否被调用？
4. 传递的参数是否正确？

### 传统方式 (手动验证)
```python
# 手动运行程序，观察UI是否更新
# 问题: 慢、不可靠、无法自动化
```

### 信号测试方式 (自动化)

#### 1. 测试信号定义
```python
def test_signal_definition(self, qapp):
    """测试信号是否正确定义"""
    from src.qt.util.qttask import QtTaskQObject
    from PySide6.QtCore import Signal
    
    task_obj = QtTaskQObject()
    
    # 验证信号存在
    assert hasattr(task_obj, 'convertBack')
    
    # 验证是Signal类型
    assert isinstance(type(task_obj).convertBack, Signal)
```

#### 2. 测试信号连接
```python
def test_signal_connection(self, qapp):
    """测试信号连接"""
    from src.qt.util.qttask import QtTaskQObject
    
    task_obj = QtTaskQObject()
    
    # 创建槽函数，记录接收到的值
    received_values = []
    
    def slot_function(task_id):
        received_values.append(task_id)
    
    # 连接信号
    task_obj.convertBack.connect(slot_function)
    
    # 发射信号
    task_obj.convertBack.emit(1001)
    
    # 处理事件循环 (重要!)
    qapp.processEvents()
    
    # 验证槽函数被调用
    assert len(received_values) == 1
    assert received_values[0] == 1001
```

#### 3. 测试多次信号发射
```python
def test_multiple_signal_emissions(self, qapp):
    """测试多次信号发射"""
    from src.qt.util.qttask import QtTaskQObject
    
    task_obj = QtTaskQObject()
    received_values = []
    
    def slot_function(task_id):
        received_values.append(task_id)
    
    task_obj.convertBack.connect(slot_function)
    
    # 发射多次
    for i in range(5):
        task_obj.convertBack.emit(1000 + i)
    
    qapp.processEvents()
    
    # 验证所有信号都被接收
    assert len(received_values) == 5
    assert received_values == [1000, 1001, 1002, 1003, 1004]
```

### 关键点: qapp.processEvents()

#### 为什么需要？
Qt信号是**异步**的，信号发射后不会立即执行槽函数，而是放入事件队列。

```python
task_obj.convertBack.emit(1001)  # 信号进入队列
# 此时槽函数还没执行!

qapp.processEvents()  # 处理事件队列，执行槽函数
# 现在槽函数执行了
```

#### 工作原理
```
1. emit(1001) → 信号进入Qt事件队列
2. qapp.processEvents() → 处理队列中的所有事件
3. 槽函数被调用 → slot_function(1001)
4. received_values.append(1001) → 记录结果
5. assert验证 → 检查结果
```

### 实际运用 - 信号到回调的完整流程
```python
def test_signal_to_callback_flow(self, qapp, mock_config):
    """测试信号到回调的完整流程"""
    from src.qt.util.qttask import QtTask, QtDownloadTask
    
    task_manager = QtTask()
    
    # 记录回调调用
    callback_results = []
    
    def test_callback(data, task_id, param, tick):
        callback_results.append(task_id)
    
    # 创建任务
    task = QtDownloadTask()
    task.downloadId = 2001
    task.downloadCompleteBack = test_callback
    task.saveData = b"test"
    task.tick = 1.0
    task_manager.convertLoad[2001] = task
    
    # 模拟HandlerConvertTask的逻辑
    if 2001 in task_manager.convertLoad:
        info = task_manager.convertLoad[2001]
        # 调用回调
        info.downloadCompleteBack(info.saveData, 2001, None, info.tick)
        # 清理任务
        del task_manager.convertLoad[2001]
    
    # 验证
    assert len(callback_results) == 1
    assert callback_results[0] == 2001
    assert 2001 not in task_manager.convertLoad  # 任务已清理
```

### 优势
✅ **自动验证**: 无需手动运行程序观察
✅ **快速反馈**: 秒级完成测试
✅ **覆盖全面**: 测试各种信号场景
✅ **防止回归**: 修改代码后确保信号机制不被破坏

---

## 五、四种技术的组合运用

### 实际案例: 测试任务管理器

```python
class TestTaskManagerIntegration:
    """组合使用四种技术"""
    
    # 使用Fixture: 自动准备Qt环境和配置
    def test_complete_workflow(self, qapp, mock_config):
        """测试完整工作流程"""
        from src.qt.util.qttask import QtTask, QtDownloadTask
        
        task_manager = QtTask()
        completed_tasks = []
        
        # 使用Mock: 模拟回调函数
        def mock_callback(data, task_id, param, tick):
            completed_tasks.append(task_id)
        
        # 使用参数化: 测试多个任务
        task_ids = [4000, 4001, 4002, 4003, 4004]
        
        for task_id in task_ids:
            task = QtDownloadTask()
            task.downloadId = task_id
            task.downloadCompleteBack = mock_callback
            task_manager.convertLoad[task_id] = task
        
        # 模拟任务完成
        for task_id in task_ids:
            task = task_manager.convertLoad[task_id]
            task.saveData = f"processed_{task_id}".encode()
            # 使用信号测试: 验证回调调用
            task.downloadCompleteBack(task.saveData, task_id, None, 1.0)
        
        # 处理事件
        qapp.processEvents()
        
        # 验证
        assert len(completed_tasks) == 5
        assert sorted(completed_tasks) == task_ids
```

---

## 六、总结对比

| 技术 | 解决的问题 | 核心价值 | 使用场景 |
|------|-----------|---------|---------|
| **参数化测试** | 重复代码 | 一次编写，多次运行 | 测试多组相似数据 |
| **Fixture** | 重复准备代码 | 自动准备和清理 | 测试环境初始化 |
| **Mock** | 外部依赖 | 隔离依赖，快速测试 | 替换GPU、网络、数据库 |
| **信号测试** | Qt异步机制 | 验证信号槽正确性 | 测试事件驱动逻辑 |

### 记忆口诀

**参数化**: 一个测试，多组数据，自动循环
**Fixture**: 自动准备，自动清理，依赖注入
**Mock**: 假对象，真测试，隔离依赖
**信号测试**: 发射信号，处理事件，验证回调

---

## 七、实战建议

### 何时使用参数化？
- ✅ 测试相同逻辑的不同输入
- ✅ 边界值测试 (最小值、最大值、零值)
- ✅ 等价类测试 (有效值、无效值)

### 何时使用Fixture？
- ✅ 多个测试需要相同的准备工作
- ✅ 需要自动清理资源
- ✅ 测试依赖外部环境 (数据库连接、文件等)

### 何时使用Mock？
- ✅ 测试依赖外部资源 (GPU、网络、文件系统)
- ✅ 外部资源慢、不稳定
- ✅ 需要模拟错误场景 (网络超时、磁盘满等)

### 何时使用信号测试？
- ✅ 使用Qt信号槽机制
- ✅ 测试异步回调
- ✅ 验证事件驱动逻辑

---

**掌握这四种技术，你就能写出高质量的自动化测试！** 🚀
